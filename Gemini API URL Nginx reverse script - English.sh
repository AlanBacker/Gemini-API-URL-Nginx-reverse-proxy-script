#!/bin/bash

# --- Configuration ---
NGINX_SITES_AVAILABLE="/etc/nginx/sites-available"
NGINX_SITES_ENABLED="/etc/nginx/sites-enabled"
# Target the entire domain
TARGET_DOMAIN="https://generativelanguage.googleapis.com"
TARGET_HOST="generativelanguage.googleapis.com" # For the Host header

# --- Color Codes ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# --- Helper Functions ---
function print_info {
    echo -e "${GREEN}[INFO] $1${NC}"
}

function print_warning {
    echo -e "${YELLOW}[WARNING] $1${NC}"
}

function print_error {
    echo -e "${RED}[ERROR] $1${NC}"
}

function check_root {
    if [[ $EUID -ne 0 ]]; then
       print_error "This script must be run as root. Please use 'sudo ./setup_google_api_proxy_en.sh' to run it."
       exit 1
    fi
}

function check_nginx {
    if ! command -v nginx &> /dev/null; then
        print_error "Nginx not found. Please install Nginx first (e.g., 'sudo apt update && sudo apt install nginx' or 'sudo yum install nginx')."
        exit 1
    fi
    print_info "Nginx installation detected."
}

# --- Main Logic ---
clear
print_info "Welcome to the Nginx Reverse Proxy Setup Script for Google API (generativelanguage.googleapis.com)"
print_warning "--------------------------------------------------"
print_warning "Important Notes:"
print_warning "1. API Key Security: It is STRONGLY recommended to have the client provide the API Key with each request (via Header or URL parameter)."
print_warning "   The configuration generated by this script DOES NOT include an API key by default. You must add it in your client requests."
print_warning "2. HTTPS: Using HTTPS for your proxy is highly recommended to secure the communication."
print_warning "--------------------------------------------------"
echo

# 1. Check prerequisites
check_root
check_nginx
echo

# 2. Get user input
read -p "Enter your server's domain name or public IP address: " server_name
while [[ -z "$server_name" ]]; do
    print_warning "Server domain or IP address cannot be empty."
    read -p "Enter your server's domain name or public IP address: " server_name
done

read -p "Enter the desired path prefix on your server to access the Google API (must start and end with /, e.g., /google-api/): " proxy_location
# Validate path format
while ! [[ "$proxy_location" =~ ^/.*\/$ ]]; do
    print_warning "Invalid path prefix format. It must start and end with / (e.g., /google-api/ )."
    read -p "Please re-enter the path prefix: " proxy_location
done

# Generate a unique config file name based on server name and prefix
sanitized_server_name=$(echo "$server_name" | tr -cd '[:alnum:]._-')
sanitized_prefix=$(echo "$proxy_location" | tr -cd '[:alnum:]_-')
config_file_name="google-api-proxy-${sanitized_server_name}-${sanitized_prefix}.conf"
config_file_path="${NGINX_SITES_AVAILABLE}/${config_file_name}"
link_path="${NGINX_SITES_ENABLED}/${config_file_name}"

read -p "Do you want to configure HTTPS (requires you to have SSL certificate files ready)? (y/n, default n): " use_https
use_https=$(echo "$use_https" | tr '[:upper:]' '[:lower:]') # Convert to lowercase

ssl_cert_path=""
ssl_key_path=""
listen_directive="listen 80;"
ssl_config_block=""
proxy_scheme="http" # Used for the final user access URL example

if [[ "$use_https" == "y" ]]; then
    listen_directive="listen 443 ssl http2;"
    proxy_scheme="https"
    print_info "HTTPS configuration selected."
    while [[ -z "$ssl_cert_path" ]]; do
        read -p "Enter the full path to your SSL certificate file (e.g., /etc/letsencrypt/live/yourdomain.com/fullchain.pem): " ssl_cert_path
        if [[ -z "$ssl_cert_path" ]]; then
            print_warning "Certificate path cannot be empty."
        # Optional: Check if file exists
        # elif [[ ! -f "$ssl_cert_path" ]]; then
        #     print_warning "Certificate file not found: $ssl_cert_path"
        #     ssl_cert_path=""
        fi
    done
     while [[ -z "$ssl_key_path" ]]; do
        read -p "Enter the full path to your SSL private key file (e.g., /etc/letsencrypt/live/yourdomain.com/privkey.pem): " ssl_key_path
         if [[ -z "$ssl_key_path" ]]; then
            print_warning "Private key path cannot be empty."
        # Optional: Check if file exists
        # elif [[ ! -f "$ssl_key_path" ]]; then
        #     print_warning "Private key file not found: $ssl_key_path"
        #     ssl_key_path=""
        fi
    done

    # Build SSL config block
    ssl_config_block=$(cat <<EOF
        # --- SSL Configuration ---
        ssl_certificate $ssl_cert_path;
        ssl_certificate_key $ssl_key_path;

        # Recommended SSL parameters (if using Let's Encrypt, consider including their options)
        # include /etc/letsencrypt/options-ssl-nginx.conf; # Uncomment if this file exists
        # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;   # Uncomment if this file exists

        # Stronger Cipher Suites and Protocols (adjust as needed)
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers off;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
EOF
)
    print_info "HTTPS configuration ready."
else
    print_info "HTTP selected (not recommended for production)."
fi
echo

# 3. Generate Nginx configuration content
print_info "Generating Nginx configuration file..."

# Use heredoc to create the config content
# Note the trailing slash on proxy_pass
nginx_config=$(cat <<EOF
server {
    $listen_directive
    server_name $server_name;

$ssl_config_block

    # Optional: Increase max allowed request body size if needed for large inputs
    # client_max_body_size 50M;

    # --- Google API Full Domain Reverse Proxy ---
    location $proxy_location {
        # Proxy target address (the trailing / is important, it replaces the matched location part)
        proxy_pass ${TARGET_DOMAIN}/;

        # Set essential proxy headers
        proxy_set_header Host \$http_host; # Pass original host header from client, this could be needed by target domain. Or you can hardcode it.
        # proxy_set_header Host $TARGET_HOST; # Alternative: Force the target host header
        proxy_set_header X-Real-IP \$remote_addr;              # Pass the real client IP
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for; # Append proxy IP(s)
        proxy_set_header X-Forwarded-Proto \$scheme;           # Pass original scheme (http/https)
        proxy_set_header Accept-Encoding "";                 # Avoid Nginx altering compression

        # SSL settings for communicating with the HTTPS backend
        proxy_ssl_server_name on; # Enable SNI, required by many modern web services like Google's
        # proxy_ssl_verify on;      # Recommended: Verify the backend SSL certificate (may need proxy_ssl_trusted_certificate)
        # proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt; # Path to CA certificate bundle (adjust for your OS)
        # If SSL verification causes issues, temporarily turn off for testing (NOT recommended for production):
        # proxy_ssl_verify off;

        # Timeout and buffering settings (adjust as needed)
        # proxy_connect_timeout 60s;
        # proxy_send_timeout   120s; # Increase for potentially long API calls
        # proxy_read_timeout   120s;
        proxy_buffering off;      # Recommended to disable buffering for streaming APIs (like Gemini streamGenerateContent) or SSE
        proxy_http_version 1.1;   # Use HTTP/1.1 for backend connections
        proxy_set_header Connection ""; # Clear the Connection header, helpful for managing keep-alives

        # --- API Key Handling ---
        # !! Recommended Method: Client provides the API Key in the request !!
        # Nginx will forward client's 'x-goog-api-key' header or 'key' URL parameter by default.
        # Client call example (Header):
        # curl -H "x-goog-api-key: YOUR_API_KEY" ... ${proxy_scheme}://$server_name${proxy_location}v1beta/models/gemini-pro:generateContent
        # Client call example (URL parameter):
        # curl ... "${proxy_scheme}://$server_name${proxy_location}v1beta/models/gemini-pro:generateContent?key=YOUR_API_KEY"

        # --- Not Recommended: Adding API Key in Nginx (Security Risk) ---
        # If you absolutely must do this and understand the risks, uncomment the line below and replace the key.
        # proxy_set_header x-goog-api-key YOUR_ACTUAL_GEMINI_API_KEY;
        # WARNING: Ensure this Nginx configuration file's permissions are strictly controlled if you store a key here!
    }

    # Optional: Handle root path or other paths
    location / {
        # Return 'Forbidden' to prevent exposing the server directly
        return 403 "Forbidden - Access API via proxy path ${proxy_location}";
        # Or serve a static page
        # root /var/www/html;
        # index index.html index.htm;
    }

    # Log file paths
    access_log /var/log/nginx/${config_file_name}.access.log;
    error_log /var/log/nginx/${config_file_name}.error.log;
}
EOF
)

# 4. Write the configuration file
print_info "Writing configuration to: $config_file_path"
# Use sudo tee to write the file as root
echo "$nginx_config" | sudo tee "$config_file_path" > /dev/null
if [[ $? -ne 0 ]]; then
    print_error "Failed to write configuration file! Check permissions or disk space."
    exit 1
fi
print_info "Configuration file created successfully."
echo

# 5. Create symbolic link to enable the site
print_info "Enabling configuration (creating symbolic link)..."
# Use -f to force overwrite if a link already exists
sudo ln -sf "$config_file_path" "$link_path"
if [[ $? -ne 0 ]]; then
    print_error "Failed to create symbolic link!"
    exit 1
fi
print_info "Configuration enabled: $link_path -> $config_file_path"
echo

# 6. Finish and provide next steps
print_info "--------------------------------------------------"
print_info "Configuration Complete!"
print_info "--------------------------------------------------"
echo -e "${YELLOW}Next Steps:${NC}"
echo -e "1. ${GREEN}Test Nginx configuration syntax:${NC}"
echo -e "   sudo nginx -t"
echo
echo -e "2. ${GREEN}If the test is successful (shows 'syntax is ok' and 'test is successful'), reload Nginx service:${NC}"
echo -e "   sudo systemctl reload nginx"
echo
echo -e "3. ${GREEN}Use your reverse proxy:${NC}"
echo -e "   You can now access the Google API via '${proxy_scheme}://$server_name${proxy_location}' followed by the actual API path."
echo -e "   For example, to generate content with Gemini Pro:"
echo -e "   ${YELLOW}POST ${proxy_scheme}://$server_name${proxy_location}v1beta/models/gemini-pro:generateContent${NC}"
echo -e "   To use Gemini Pro Vision:"
echo -e "   ${YELLOW}POST ${proxy_scheme}://$server_name${proxy_location}v1beta/models/gemini-pro-vision:generateContent${NC}"
echo -e "   To list models:"
echo -e "   ${YELLOW}GET ${proxy_scheme}://$server_name${proxy_location}v1beta/models${NC}"
echo
echo -e "   ${YELLOW}IMPORTANT:${NC} Remember to include your Google API Key in your client requests, either via the 'x-goog-api-key' HTTP header or the 'key' URL parameter."
echo
print_warning "Please double-check your firewall settings to ensure port 80 (HTTP) and/or 443 (HTTPS) are open for inbound connections."
print_info "Script execution finished."

exit 0
